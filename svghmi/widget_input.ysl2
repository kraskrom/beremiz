// widget_input.ysl2

widget_desc("Input") {
    longdesc
    ||
    Input widget takes one variable path, and displays current value in
    optional "value" labeled sub-element. 

    Click on optional "edit" labeled element opens keypad to edit value.
    
    Operation on current value is performed when click on sub-elements with
    label starting with '=', '+' or '-' sign. Value after sign is used as
    operand.
    ||

    shortdesc > Input field with predefined operation buttons

    arg name="format" accepts="string" > optional printf-like format 

    path name="edit" accepts="HMI_INT, HMI_REAL, HMI_STRING" > single variable to edit
}

widget_class("Input") {
||
    on_op_mouse_up() {
        svg_root.removeEventListener("pointerup", this.bound_on_op_mouse_up[this.pressed_index], true);
        set_activity_state(this.activable_sub[this.pressed_index], false);
        this.change_hmi_value(0, this.change_value);
    }

    on_op_mouse_down(index, cv) {
        svg_root.addEventListener("pointerup", this.bound_on_op_mouse_up[index], true);
        this.change_value = cv;
        this.pressed_index = index;
        set_activity_state(this.activable_sub[index], true);
    }

    edit_callback(new_val) {
        this.apply_hmi_value(0, new_val);
    }

    is_inhibited = false;
    alert(msg){
        this.is_inhibited = true;
        this.display = msg;
        setTimeout(() => this.stopalert(), 1000);
        this.request_animate();
    }

    stopalert(){
        this.is_inhibited = false;
        this.display = this.last_value;
        this.request_animate();
    }

    overshot(new_val, max) {
        this.alert("max");
    }

    undershot(new_val, min) {
        this.alert("min");
    }

    display = "";
||
}


widget_defs("Input") {
    const "value_elt" optional_labels("value");
    const "have_value","string-length($value_elt)>0";
    value "$value_elt";

    const "edit_elt" optional_labels("edit");
    const "have_edit","string-length($edit_elt)>0";
    value "$edit_elt";

    const "action_elements", "$hmi_element/*[regexp:test(@inkscape:label,'^[=+\-].+')]";

    if "$have_value" {
    |   frequency: 5,
    }
    |   dispatch: function(value) {
    if "$have_value or $have_edit" {
        choose {
            when "count(arg) = 1" {
    |       this.last_value = vsprintf("«arg[1]/@value»", [value]);
            }
            otherwise {
    |       this.last_value = value;
            }
        }
    |       if(!this.is_inhibited) {
    |           this.display = this.last_value;
        if "$have_value" {
    |           this.request_animate();
        }
    |       }
    }
    |   },

    if "$have_value" {
    |   animate: function(){
    |       multiline_to_svg_text(this.value_elt, String(this.display));
    |   },
    }

    if "count($action_elements) > 0" {
    |   action_elt: [],
    |   activable_sub: [],
    |   bound_on_op_mouse_up: [],
    |   pressed_index: -1,
    |   change_value: "0",
    }

    |   init: function() {
    if "$have_edit" {
    |       this.edit_elt.onclick = () => edit_value("«path/@value»", "«path/@type»", this, this.last_value);
        if "$have_value" {
    |       this.value_elt.style.pointerEvents = "none";
        }
    |       this.animate();
    }

    |       var sub;

    foreach "$action_elements" {
        const "pos", "position() - 1";
        const "current_id", "@id";
        const "active", "$hmi_element/*[@id = $current_id]/*[regexp:test(@inkscape:label,'active')]";
    |       this.action_elt.push(id("«@id»"));
    |       this.action_elt[«$pos»].onmousedown = () => this.on_op_mouse_down(«$pos», "«func:escape_quotes(@inkscape:label)»");
    |       this.bound_on_op_mouse_up.push(this.on_op_mouse_up.bind(this));
    |       sub = {
        foreach "$active" {
    |           «@inkscape:label»_elt: id("«@id»")`if "position()!=last()" > ,`
        }
    |       };
    |       this.activable_sub.push(sub);
    }

    if "$have_value" {
    |       multiline_to_svg_text(this.value_elt, "");
    }
    |   },
}
